\documentclass[12pt]{report}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphics}
\usepackage{subfigure}
\usepackage{lipsum}
\usepackage{array}
\usepackage{multicol}
\usepackage{enumerate}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage[a4paper, margin = 1.5cm]{geometry}

%En esta parte se hacen redefiniciones de algunos comandos para que resulte agradable el verlos%

\renewcommand{\theenumii}{\roman{enumii}}

\def\proof{\paragraph{Demostración:\\}}
\def\endproof{\hfill$\blacksquare$}

\def\sol{\paragraph{Solución:\\}}
\def\endsol{\hfill$\square$}

%En esta parte se definen los comandos a usar dentro del documento para enlistar%

\newtheoremstyle{largebreak}
  {}% use the default space above
  {}% use the default space below
  {\normalfont}% body font
  {}% indent (0pt)
  {\bfseries}% header font
  {}% punctuation
  {\newline}% break after header
  {}% header spec

\theoremstyle{largebreak}

\newmdtheoremenv[
    leftmargin=0em,
    rightmargin=0em,
    innertopmargin=-2pt,
    innerbottommargin=8pt,
    hidealllines = true,
    roundcorner = 5pt,
    backgroundcolor = gray!60!red!30
]{exa}{Ejemplo}[section]

\newmdtheoremenv[
    leftmargin=0em,
    rightmargin=0em,
    innertopmargin=-2pt,
    innerbottommargin=8pt,
    hidealllines = true,
    roundcorner = 5pt,
    backgroundcolor = gray!50!blue!30
]{obs}{Observación}[section]

\newmdtheoremenv[
    leftmargin=0em,
    rightmargin=0em,
    innertopmargin=-2pt,
    innerbottommargin=8pt,
    rightline = false,
    leftline = false
]{theor}{Teorema}[section]

\newmdtheoremenv[
    leftmargin=0em,
    rightmargin=0em,
    innertopmargin=-2pt,
    innerbottommargin=8pt,
    rightline = false,
    leftline = false
]{propo}{Proposición}[section]

\newmdtheoremenv[
    leftmargin=0em,
    rightmargin=0em,
    innertopmargin=-2pt,
    innerbottommargin=8pt,
    rightline = false,
    leftline = false
]{cor}{Corolario}[section]

\newmdtheoremenv[
    leftmargin=0em,
    rightmargin=0em,
    innertopmargin=-2pt,
    innerbottommargin=8pt,
    rightline = false,
    leftline = false
]{lema}{Lema}[section]

\newmdtheoremenv[
    leftmargin=0em,
    rightmargin=0em,
    innertopmargin=-2pt,
    innerbottommargin=8pt,
    roundcorner=5pt,
    backgroundcolor = gray!30,
    hidealllines = true
]{mydef}{Definición}[section]

\newmdtheoremenv[
    leftmargin=0em,
    rightmargin=0em,
    innertopmargin=-2pt,
    innerbottommargin=8pt,
    roundcorner=5pt
]{excer}{Ejercicio}[section]

%En esta parte se colocan comandos que definen la forma en la que se van a escribir ciertas funciones%

\newcommand\abs[1]{\ensuremath{\biglvert#1\bigrvert}}
\newcommand\divides{\ensuremath{\bigm|}}
\newcommand\cf[3]{\ensuremath{#1:#2\rightarrow#3}}

%recuerda usar \clearpage para hacer un salto de página

\begin{document}
    \title{Curso de Lógica Matemática}
    \author{Cristo Daniel Alvarado}
    \maketitle

    \tableofcontents %Con este comando se genera el índice general del libro%

    \setcounter{chapter}{-1} %En esta parte lo que se hace es cambiar la enumeración del capítulo%
    
    \chapter{Introducción}
    
    \section{Temario}
    

    Los siguientes temas se verán a lo largo del curso:

    \renewcommand{\theenumii}{\arabic{enumi}.\arabic{enumii}}

    \begin{enumerate}
        \item Lógica (Teoría de Modelos).
        \begin{enumerate}
            \item Lógica proposicional.
            \item Lógica de primer orden.
        \end{enumerate}
        \item Teoría de la Computabilidad.
        \item Teoría de Conjuntos.
    \end{enumerate}

    Y la bibliografía para el curso es la siguiente:

    \begin{itemize}
        \item Enderton, 'Introducción matemática a la lógica'.
        \item  Enderton, 'Teoría de la computabilidad'.
        \item Copi, 'Lógica Simbólica' o 'Computability Theory'.
        \item Rebeca Weber 'Computability Theory'.
    \end{itemize}

    \section{Conectivas Lógicas}

    La disyunción ($\land$), conjunción ($\lor$), negación ($\neg$), implicación ($\Rightarrow$) y si y sólo si ($\iff$) son las conectivas lógicas usadas usualmente. 

    (Se habló un poco de una cosa llamada forma normal disyuntiva).
    
    A $\left\{\land, \lor, \neg \right\}$ se le conoce como un conjunto completo de conectivas lógicas. Nos podemos quedar simplemente con conjuntos completos de disyuntivas con solo dos elementos, a saber: $\left\{\land, \neg \right\}$ y $\left\{\lor, \neg \right\}$, ya que $P\lor Q$ es $\neg(\neg P\land \neg Q)$. (de forma similar a lo otro $P\land Q$ es $\neg(\neg P\lor \neg Q)$).

    También $\left\{\Rightarrow, \neg \right\}$ es otro conjunto completo de conectivas lógicas, ya que $P\land Q$ es $\neg(P\Rightarrow\neq Q)$.

    Y, $\left\{|\right\}$ es un conjunto completo, donde $|$ es llamado la \textbf{barra de Scheffel}, que tiene la siguiente tabla de verdad.

    \begin{center}
        \begin{tabular}{c c | c}
            \hline
            $P$ & $Q$ & $P|Q$ \\
            \hline
            $V$ & $V$ & $F$ \\
            $V$ & $F$ & $V$ \\
            $F$ & $V$ & $V$ \\
            $F$ & $F$ & $V$ \\
        \end{tabular}
    \end{center}
    con este, se tiene un conjunto completo de conectivas lógicas.

    Como muchas veces se usan conectivas de este tipo:
    \begin{equation*}
        (P\Rightarrow \neg Q)\Rightarrow((P\Rightarrow R)\land\neg(Q\Rightarrow S)\land T)
    \end{equation*}
    al ser muy largas, a veces es más conveniente escribirlas en forma Polaca. De esta forma, lo anterior quedaría de la siguiente manera:
    \begin{equation*}
        \Rightarrow\Rightarrow P\neg Q\land\land PR\neg\Rightarrow Q S T 
    \end{equation*}

    Ahora empezamos con el estudio formal de la lógica.

    \chapter{Lógica Proposicional}

    \section{Alfabeto}

    El alfabeto de la lógica proposicional es un conjunto que consta de dos tipos de símbolos:
    \begin{enumerate}
        \item \textbf{Variables}, denotadas por $p_1,p_2,...,p_n,...$ (a lo más una cantidad numerable). Estas representan proposiciones o enunciados (tengo un paraguas, me caí de las escaleras, no tengo café en la cafetera, etc\dots).
        \item \textbf{Conectivas}, como $\Rightarrow$ y $\neg$.
    \end{enumerate}
    Aceptamos la existencia de estas cosas (pues, al menos debemos aceptar la existencia de algo).

    Se van a trabajar con sucesiones finitas de símbolos del alfabeto descrito anteriormente. Ahora necesitaremos especificar que tipos de sucesiones van a servirnos para tener un significado formal.

    \begin{mydef}
        En el conjunto de sucesiones finitas de símbolos del alfabeto, definimos una \textbf{fórmula bien formada} (abreviada como \textbf{FBF}) como sigue:
        \begin{enumerate}
            \item Cada variable es una \textbf{FBF}.
            \item Si $\varphi,\psi$ son \textbf{FBF}, entonces $\neg\varphi$ y $\Rightarrow\varphi\psi$ también lo son.
        \end{enumerate}
    \end{mydef}

    \begin{obs}
        Recordar que usamos la notación Polaca en la definición anterior.
    \end{obs}

    A continuación unos ejemplos:
    
    \begin{exa}
        $p_{17}$, $p_{54}$ y $\Rightarrow p_2p_{25}$ son FBF. Las primeras dos son llamadas \textbf{variables aisladas}. También lo es $\neg \Rightarrow p_2p_{25}$ (en este ejemplo, los $p_i$ son variables).

        Pero, por ejemplo $\Rightarrow \neg p_1 p_2 p_3$ y $\Rightarrow p_4$ no son FBF.
    \end{exa}

    Viendo el ejemplo anterior, notamos que el operador $\Rightarrow$ es binario (solo usa dos entradas) y $\neg$ es unario (solo una entrada). Por lo cual, añadir o no demás variables a los opeadores dentro de la fórmula, hace que la fórmula ya no sea una FBF.

    \begin{obs}
        Eventualmente se va a sustituir la notación Polaca por la normal, para que se pueda leer la FBF y el proceso no sea robotizado.
    \end{obs}

    Definiremos ahora más conectivas lógicas para poder trabajar más cómodamente.

    \begin{mydef}
        Se definirán tres conectivas lógicos adicionales.
        \begin{enumerate}
            \item Se define la \textbf{disyunción} $\varphi\lor\psi$ como $\Rightarrow\neg\psi\varphi$ (en notación Polaca).
            \item Se define la \textbf{conjunción} $\varphi\land\psi$ como $\neg(\neg\psi\lor\neg\varphi)$.
            \item Se define el \textbf{si sólo si} $\psi\iff\varphi$ como $(\psi\Rightarrow\varphi)\land(\varphi\Rightarrow\psi)$.
        \end{enumerate}
    \end{mydef}

    \section{Modeos o Estructuras}

    En el fondo, queremos que las FBF sean cosas verdaderas o falsas. Un Modelo o Estructura es algo que le va a dar significado a las FBF. De alguna manera va a ser una forma de asignarle el valor de verdadero o falso a cada una de las variables.

    \begin{mydef}
        Un \textbf{Modelo o Estructura} de la lógica proposicional es una función $\cf{m}{\textup{Var}}{\left\{V,F\right\}}$, donde Var denota al conjunto de símbolos que son variables. Básicamente estamos diciendo que hay variables que son verdaderas y otras que son falsas.
    \end{mydef}

    \begin{theor}
        Para todo modelo $m$, existe una única extensión $\cf{\overline{m}}{\textup{FBF}}{\left\{V,F\right\}}$, donde FBF denota al conjunto de las fórmulas bien formadas, tal que $\overline{m}(\neg\varphi)=V\iff \overline{m}(\varphi)=F$ y $\overline{m}(\neg\varphi\psi)=F\iff\overline{m}(\varphi)=V$ y $\overline{m}(\psi)=F$.
    \end{theor}

    \begin{mydef}
        Sea $m$ un modelo, $\varphi$ una fórmula y $\Sigma$ un cojunto de fórmulas. Definimos que
        \begin{enumerate}
            \item $m\vDash \varphi$ ($m$ satisface $\varphi$) si $\overline{m}(\varphi)=V$.
            \item $m\vDash \Sigma$ si $m\vDash\varphi$ para cada $\varphi$ elemento de $\Sigma$.
        \end{enumerate}
    \end{mydef}

    \begin{exa}
        Sea $m$ un modelo tal que $m(p_1)=V$ y $m(p_i)=F$, para todo $i\geq2$. En este caso $m\nvDash \Rightarrow p_1p_3$, pero $m\vDash \neg p_5$.
    \end{exa}
    
    \begin{mydef}
        Decimos que una fórmula $\varphi$ es:
        \begin{enumerate}
            \item \textbf{Satisfacible} si existe un modelo $m$ tal que $m\vDash\varphi$.
            \item \textbf{Contradictoria} si todo modelo cumple que $m\nvDash\varphi$.
            \item \textbf{Una tautología} si todo modelo $m$ cumple que $m\vDash\varphi$.
        \end{enumerate}
    \end{mydef}

    \begin{exa}
        Tomemos de ejemplo a $\Rightarrow p_1 p_2$. cualquier modelo que haga a $p_1$ y $p_3$ verdaderas, o ambas falsas satisfacen la FBF, $p_1$, $\neg\Rightarrow p_1 p_3$ o $\neg(p_1\Rightarrow\neg p_1)$. Por lo cual, esta fórmula es satisfacible.

        En cambio, $\neg(p_1\Rightarrow p_1)$ es contradictoria y, por ende $p_1\Rightarrow p_1$ y $\neg p_1\Rightarrow\neg p_1$ son tautologías.
    \end{exa}

    \begin{mydef}
        Sea $\Sigma$ un conjunto de fórmulas. Decimos que $\Sigma$ es
        \begin{enumerate}
            \item \textbf{Satisfacible} si existe un modelo $m$ tal que $m\vDash\Sigma$.
            \item \textbf{Contradictoria} si todo modelo cumple que $m\nvDash\Sigma$.
            \item \textbf{Una tautología} si todo modelo $m$ cumple que $m\vDash\Sigma$.
        \end{enumerate}
    \end{mydef}

    \begin{exa}
        El conjunto de fórmulas $\Sigma=\left\{\Rightarrow p_1p_2, p_1,\neg p_2 \right\}$ no es satisfacible (en este caso, es contradictorio).
    \end{exa}

    \begin{obs}
        Se tiene lo siguiente:
        \begin{enumerate}
            \item Una tautología $\Rightarrow$ satisfacible.
            \item $\varphi$ es satisfacible $\iff$ $\neg\varphi$ es una contradicción.
            \item Satisfacible es lo mismo que no contradictoria.
        \end{enumerate}
    \end{obs}

    \begin{mydef}
        Si $\Sigma$ es un conjunto de FBF y $\varphi$ es alguna otra fórmula, entonces decimos que $\varphi$ es \textbf{consecuencia lógica} de $\Sigma$, o que $\Sigma$ \textbf{implica lógicamente} a $\varphi$, escrito como $\Sigma\vDash\varphi$, si para todo modelo $m$ tal que $m\vDash\Sigma$ se tiene que $m\vDash\varphi$.
    \end{mydef}

    \begin{exa}
        El conjunto  de FBF $\left\{\Rightarrow p_1 p_2, p_1\right\}\vDash p_2$.
    \end{exa}

    \begin{obs}
        \begin{enumerate}
            Se tiene lo siguiente:
            \item Un conjunto de FBF $\Sigma\nvDash\varphi$ si y sólo si $\Sigma\cup\left\{\neg\varphi \right\}$ es satisfacible.
            \item Además, un conjunto de FBF $\Sigma\vDash\varphi$ si y sólo si $\Sigma\cup\left\{\neg\varphi \right\}$ no es satisfacible.
        \end{enumerate}
    \end{obs}

    \begin{lema}
        Sea $\Sigma$ un conjunto de fórmulas y sean Var$(\Sigma)$ el conjunto de las variables $p_i$ que aparecen en las fórmulas de $\Sigma$. Si $m_1$ y $m_2$ son dos modelos tales que
        \begin{equation*}
            m_1|_{\textup{Var}(\Sigma)}=m_2|_{\textup{Var}(\Sigma)}
        \end{equation*}
        entonces, $\overline{m_1}|_{\Sigma}=\overline{m_2}|_{\Sigma}$. En particular, para cada fórmula $\varphi$ que sea elemento de $\Sigma$, entonces $m_1\vDash\varphi$ si y sólo si $m_2\vDash\varphi$, más aún $m_1\vDash\Sigma$ si y sólo si $m_2\vDash\Sigma$.
    \end{lema}

    \begin{proof}
        Sin pérdida de generalidad, $\Sigma$ es cerrado bajo subformulas.
        
        Procederemos por inducción sobre $\varphi\in\Sigma$, demostraremos que $\overline{m_1}(\varphi)=\overline{m_2}(\varphi)$.
        Si $\varphi$ coincide con algún $p_i$, entonces $p_i\in\textup{Var}(\Sigma)$ y, por tanto
        \begin{equation*}
            \overline{m_1}(p_i)=m_1(p_i)=m_2(p_i)=\overline{m_2}(p_i)
        \end{equation*}
        Ahora hacemos el paso inductivo. 
        \begin{enumerate}
            \item Tenemos el caso en que $\varphi$ es de la forma $\neg\psi$ y suponemos que $\overline{m_1}(\psi)=\overline{m_2}(\psi)$. Se tiene que $\overline{m_1}(\neg \psi)=F\iff \overline{m_1}(\psi) = V \iff\overline{m_2}(\psi)=V\iff\overline{m_2}(\neg \psi)=F$. Por lo tanto, $\overline{m_1}(\psi)=\overline{m_2}(\psi)$. El caso en que sea verdadero es análogo.
            
            \item Tenemos el caso en que $\varphi$ es de la forma $\Rightarrow\varphi_1\psi$ y, supontemos que $\overline{m_1}(\varphi_1)=\overline{m_2}(\varphi_1)$ y $\overline{m_1}(\psi)=\overline{m_2}(\psi)$. Se tiene que $\overline{m_1}(\Rightarrow\varphi_1\psi)=F\iff\overline{m_1}(\varphi_1)=V$ y $\overline{m_1}(\psi)=F\iff$ (por hipótesis de inducción) $\overline{m_2}(\varphi_1)=V$ y $\overline{m_2}(\psi)=F\iff\overline{m_2}(\Rightarrow\varphi_1\psi)=F$. El caso en que sean verdaderas es análogo. Por tanto, $\overline{m_1}(\Rightarrow\varphi_1\psi)=\overline{m_2}(\Rightarrow\varphi_1\psi)$.
        \end{enumerate}
        Lo cual completa el paso inductivo.
    \end{proof}

    \begin{cor}
        Si $\Sigma$ es un conjunto finito de fórmulas, entonces se puede verificar 'Mecánicamente' si es el caso, que $\Sigma\vDash\varphi$.
    \end{cor}

    El procedimiento para verificar el modelo, se hace mediante la tabla de verdad de las variables y las FBF de $\Sigma$.

    \begin{mydef}
        Decimos que un conjunto de fórmulas bien formadas $\Sigma$ es \textbf{finitamente satisfacible} si cualquier subconjunto finito $\Delta\subseteq\Sigma$ es satisfacible.
    \end{mydef}

    \begin{theor}[Teorema de Compacidad de Gödel]
        Si $\Sigma$ es un conjunto (arbitrario) de fórmulas tal que $\Sigma\vDash\varphi$, entonces existe un $\Delta\subseteq\Sigma$ finito tal que $\Delta\vDash\varphi$.
    \end{theor}

    El teorema que Gödel probó originalmente fue este:

    \begin{theor}[Teorema de Gödel]
        Un conjunto de fórmulas $\Sigma$ es satisfacible si y sólo si es finitamente satisfacible.
    \end{theor}

    Veamos por qué el teorema de Gödel implica el teorema de compacidad de Gödel. Se tiene que $\Sigma\nvDash\varphi\iff$ existe un modelo $m$ tal que $m\vDash\Sigma\cup\left\{\neg\varphi \right\}$. Es decir, si y sólo si $\Sigma\cup\left\{\neg\varphi \right\}$ es satisfacible, es decir que es finitamente satisfacible (por el teorema de Gödel), es decir que para todo $\Delta\subseteq\Sigma$ finito se cumple que
    \begin{equation*}
        \Delta\cup\left\{\neg\varphi \right\}
    \end{equation*}
    es satisfacible. Y esto sucede si y sólo si para todo $\Delta\subseteq\Sigma$ finito existe $m$ tal que $m\vDash\Delta\cup\left\{\neg\varphi \right\}$, si y sólo si para todo $\Delta\subseteq\Sigma$ finito $\Delta\nvDash\varphi$, con lo cual
    \begin{equation*}
        \Sigma\nvDash\varphi\iff\Delta\nvDash\varphi
    \end{equation*}
    para todo $\Delta\subseteq\Sigma$ finito, que es el teorema de compacidad en su forma contrapositiva.

    \begin{lema}
        Sea $\Sigma$ un conjunto finitamente satisfacible, y sea $\varphi$ cualquier fórmula, entonces o bien $\Sigma\cup\left\{\varphi\right\}$ es finitamente satisfacible o $\Sigma\cup\left\{\neg\varphi\right\}$ lo es.
    \end{lema}

    \begin{proof}
        Supongamos que no, es decir que tanto $\Sigma\cup\left\{\varphi\right\}$ como $\Sigma\cup\left\{\neg\varphi\right\}$ no son finitamente satisfacibles, por lo cual existen $\Delta_1,\Delta_2\subseteq\Sigma$ finitos tales que $\Delta_1\cup\left\{\varphi \right\}$ y $\Delta_2\cup\left\{\neg\varphi \right\}$ no son satisfacibles.
        Entonces $\Delta_1\cup\Delta_2$ no puede ser satisfacible.
    \end{proof}

\end{document}