\documentclass[12pt]{report}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{graphics}
\usepackage{subfigure}
\usepackage{lipsum}
\usepackage{array}
\usepackage{multicol}
\usepackage{enumerate}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage[a4paper, margin = 1.5cm]{geometry}
\usepackage{tikz}
\usepackage{pgffor}
\usepackage{ifthen}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{mathdots}

%Gestión de Hipervínculos

\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,      
    urlcolor=cyan
}

%Gestión de Código de Programación

\definecolor{listing-background}{HTML}{F7F7F7}
\definecolor{listing-rule}{HTML}{B3B2B3}
\definecolor{listing-numbers}{HTML}{B3B2B3}
\definecolor{listing-text-color}{HTML}{000000}
\definecolor{listing-keyword}{HTML}{435489}
\definecolor{listing-keyword-2}{HTML}{1284CA} % additional keywords
\definecolor{listing-keyword-3}{HTML}{9137CB} % additional keywords
\definecolor{listing-identifier}{HTML}{435489}
\definecolor{listing-string}{HTML}{00999A}
\definecolor{listing-comment}{HTML}{8E8E8E}

\lstdefinestyle{myStyle}{
    language         = java,
    alsolanguage     = scala,
    numbers          = left,
    xleftmargin      = 2.7em,
    framexleftmargin = 2.5em,
    backgroundcolor  = \color{gray!15},
    basicstyle       = \color{listing-text-color}\linespread{1.0}\ttfamily,
    breaklines       = true,
    frameshape       = {RYR}{Y}{Y}{RYR},
    rulecolor        = \color{black},
    tabsize          = 2,
    numberstyle      = \color{listing-numbers}\linespread{1.0}\small\ttfamily,
    aboveskip        = 1.0em,
    belowskip        = 0.1em,
    abovecaptionskip = 0em,
    belowcaptionskip = 1.0em,
    keywordstyle     = {\color{listing-keyword}\bfseries},
    keywordstyle     = {[2]\color{listing-keyword-2}\bfseries},
    keywordstyle     = {[3]\color{listing-keyword-3}\bfseries\itshape},
    sensitive        = true,
    identifierstyle  = \color{listing-identifier},
    commentstyle     = \color{listing-comment},
    stringstyle      = \color{listing-string},
    showstringspaces = false,
}

\lstset{style = myStyle}

%Gestión de Marca de Agua

\usetikzlibrary{shapes.multipart}

\newcounter{it}
\newcommand*\watermarktext[1]{\begin{tabular}{c}
    \setcounter{it}{1}%
    \whiledo{\theit<100}{%
    \foreach \col in {0,...,15}{#1\ \ } \\ \\ \\
    \stepcounter{it}%
    }
    \end{tabular}
    }

\AddToHook{shipout/foreground}{
    \begin{tikzpicture}[remember picture,overlay, every text node part/.style={align=center}]
        \node[rectangle,black,rotate=30,scale=2,opacity=0.04] at (current page.center) {\watermarktext{Cristo Daniel Alvarado ESFM\quad}};
  \end{tikzpicture}
}
%En esta parte se hacen redefiniciones de algunos comandos para que resulte agradable el verlos%

\def\proof{\paragraph{Demostración:\\}}
\def\endproof{\hfill$\blacksquare$}

\def\sol{\paragraph{Solución:\\}}
\def\endsol{\hfill$\square$}

%En esta parte se definen los comandos a usar dentro del documento para enlistar%

\newtheoremstyle{largebreak}
  {}% use the default space above
  {}% use the default space below
  {\normalfont}% body font
  {}% indent (0pt)
  {\bfseries}% header font
  {}% punctuation
  {\newline}% break after header
  {}% header spec

\theoremstyle{largebreak}

\newmdtheoremenv[
    leftmargin=0em,
    rightmargin=0em,
    innertopmargin=0pt,
    innerbottommargin=5pt,
    hidealllines = true,
    roundcorner = 5pt,
    backgroundcolor = gray!60!red!30
]{exa}{Ejemplo}[section]

\newmdtheoremenv[
    leftmargin=0em,
    rightmargin=0em,
    innertopmargin=0pt,
    innerbottommargin=5pt,
    hidealllines = true,
    roundcorner = 5pt,
    backgroundcolor = gray!50!blue!30
]{obs}{Observación}[section]

\newmdtheoremenv[
    leftmargin=0em,
    rightmargin=0em,
    innertopmargin=0pt,
    innerbottommargin=5pt,
    rightline = false,
    leftline = false
]{theor}{Teorema}[section]

\newmdtheoremenv[
    leftmargin=0em,
    rightmargin=0em,
    innertopmargin=0pt,
    innerbottommargin=5pt,
    rightline = false,
    leftline = false
]{propo}{Proposición}[section]

\newmdtheoremenv[
    leftmargin=0em,
    rightmargin=0em,
    innertopmargin=0pt,
    innerbottommargin=5pt,
    rightline = false,
    leftline = false
]{cor}{Corolario}[section]

\newmdtheoremenv[
    leftmargin=0em,
    rightmargin=0em,
    innertopmargin=0pt,
    innerbottommargin=5pt,
    rightline = false,
    leftline = false
]{lema}{Lema}[section]

\newmdtheoremenv[
    leftmargin=0em,
    rightmargin=0em,
    innertopmargin=0pt,
    innerbottommargin=5pt,
    roundcorner=5pt,
    backgroundcolor = gray!30,
    hidealllines = true
]{mydef}{Definición}[section]

\newmdtheoremenv[
    leftmargin=0em,
    rightmargin=0em,
    innertopmargin=0pt,
    innerbottommargin=5pt,
    roundcorner=5pt
]{excer}{Ejercicio}[section]

%En esta parte se colocan comandos que definen la forma en la que se van a escribir ciertas funciones%

\newcommand\abs[1]{\ensuremath{\left|#1\right|}}
\newcommand\divides{\ensuremath{\bigm|}}
\newcommand\cf[3]{\ensuremath{#1:#2\rightarrow#3}}
\newcommand\contradiction{\ensuremath{\#_c}}
\newcommand\natint[1]{\ensuremath{\left[\big|#1\big|\right]}}

\begin{document}
    \setlength{\parskip}{5pt} % Añade 5 puntos de espacio entre párrafos
    \setlength{\parindent}{12pt} % Pone la sangría como me gusta
    \title{Lista 3 de Problemas y Ejercicios
    
    Lógica Matemática}
    \author{Cristo Daniel Alvarado}
    \maketitle

    %\setcounter{chapter}{3} %En esta parte lo que se hace es cambiar la enumeración del capítulo%

    \newpage

    \setcounter{chapter}{3}

    \section{Ejercicios}
   
    \begin{excer}
        Demuestre que todo subconjunto cofinito de $\mathbb{N}$ (es decir, cuyo complemento es finito) es computable.
    \end{excer}

    \begin{proof}
        Sea $X\subseteq\mathbb{N}$ un conjunto cofinito, entonces su complemento $\mathbb{N}\setminus X$ es finito. Sea $N\in\mathbb{N}$, se tiene que la función característica $\chi_{\left\{N \right\}}$ es computable, pues tiene como algoritmo:
        \begin{lstlisting}
int chi_N(int n){
    if(n == N) return 1;
    else return 0;
}
        \end{lstlisting}
        por lo que el conjunto $\left\{N \right\}$ es computable, en particular el conjunto:
        \begin{equation*}
            \mathbb{N}\setminus X=\left\{n\in\mathbb{N}\Big|n\notin X \right\}
        \end{equation*}
        es computable (por ser finito) ya que es unión finita de conjuntos numerables, luego su complemento el cual es $X$ es computable.
    \end{proof}

    \begin{excer}
        Suponga que $X\subseteq\mathbb{N}$ es computable, y sea $\cf{f}{\mathbb{N}}{\mathbb{N}}$ una función total computable. Demuestre que:
        \begin{equation*}
            f^{-1}[X]=\left\{n\in\mathbb{N}\Big|f(n)\in X \right\}
        \end{equation*}
        es un conjunto computable.
    \end{excer}

    \begin{proof}
        Considere el siguiente algoritmo de la función característica de $f^{-1}[X]$:

        \begin{lstlisting}
int f_1_[X](int n){
    if(chi_X(f(n))) return 1;
    else return 0;
}
        \end{lstlisting}
        como $f$ es total computable, entonces $f(n)$ existe para todo $n$, luego al ser $X$ un conjunto computable, en una cantidad finita de tiempo se obtiene si $\chi_X$ evaluada en $f(n)$ es cero o uno, en cuyo caso se retorna cero o uno en el algoritmo definido anteriormente, el cual siempre retorna algo.
    \end{proof}

    \begin{excer}
        Defina la función $\cf{f}{\mathbb{N}}{\mathbb{N}}$ mediante:
        \begin{equation*}
            f(n)=\left\{
                \begin{array}{rl}
                    1 & \textup{ si la expansión decimal de $\pi$ contiene una sucesion de al menos $n$ digitos}\\ 
                     & \textup{consecutivos iguales a 7.}\\
                    0 & \textup{ en otro caso.}\\
                \end{array}
            \right.
        \end{equation*}
        Demuestre (sin usar ningún hecho especial sobre $\pi$) que la función $f$ es total computable.
    \end{excer}

    \begin{proof}
        Es inmediato del siguiente algoritmo:
        \begin{lstlisting}
int f(int n){
    recorrer digito por digito la expansion decimal de pi hasta encontrar un 7{
        int cont = 1;
        cont cuenta el numero de 7s despues del primer 7;
        if(n <= cont) return 1;
    }
}
        \end{lstlisting}
        que $f$ es computable. Si $f$ no fuese total computable (es decir, que $f$ no sea la función constante uno), entonces existiría al menos un $N\in\mathbb{N}$ tal que $f(N)$ no está bien definido, por la forma en que definimos el algoritmo de $f$, se tendría que $N+1,...$ tampoco estarían bien definidos. Sea $n_0$ el mínimo entero no negativo tal que $f(n_0)$ no está bien definido (es decir que el algoritmo anterior sigue funcionando). Construímos el algoritmo:
        \begin{lstlisting}
int f_2(int n){
    if(n < n_0) return f(n);
    else return 0;
}
        \end{lstlisting}
        esta es el algoritmo de la función $f$, mismo que es total.
    \end{proof}

    \begin{obs}
        ¿Puedo elegir tal $n_0$ en la demostración anterior?
    \end{obs}

    \begin{excer}
        Suponga que $\cf{g}{\mathbb{N}}{\mathbb{N}}$ es una función no-creciente, es decir que $g(n+1)\leq g(n)$ para todo $n\in\mathbb{N}$. Pruebe que $g$ debe ser total computable.
    \end{excer}

    \begin{proof}
        Como $g$ es no creciente, $g$ solo puede tomar un número finito de valores en $\mathbb{N}$, digamos $c_k<c_{ k-1}<\cdots<c_1=c_0$, ya que debe quedarse o disminuir a partir de su valor inicial, el cual es $g(0)=c_0$.

        Por ser $g$ no decreciente, además debe suceder que $g^{-1}(c_i)$ es un conjunto finito, para todo $i=0,1,...,k-1$ y el conjunto $g^{-1}(c_k)$ es infinito. Por tanto, si hacemos:
        \begin{equation*}
            g^{-1}(c_i)=\left\{x_{i,0},x_{i,1},...,x_{ i,k_i}\right\},\quad\forall i=0,1,...,k-1
        \end{equation*}
        entonces el algoritmo de $g$ sería:
        \begin{lstlisting}
int g(int n){
    if(n == x_0_0 || n == x_0_1 || ... || n == x_0_k_0) return c_0;
    if(n == x_1_0 || n == x_1_1 || ... || n == x_1_k_1) return c_1;
    ... ... ;
    if(n == x_(k-1)_0 || n == x_(k-1)_1 || ... || n == x_(k-1)_k_(k-1)) return c_(k-1);
    else return c_k;
}
        \end{lstlisting}
        por lo cual, la función $g$ sería total computable.        
    \end{proof}

    \begin{excer}
        Demuestre que la función $\cf{f}{\mathbb{N}^3}{\mathbb{N}}$ dada por:
        \begin{equation*}
            f(x,y,z)=\left\{
                \begin{array}{lcr}
                    y & \textup{ si } & x=0.\\
                    z & \textup{ si } & x\neq0.\\
                \end{array}
            \right.
        \end{equation*}
        es total computable.
    \end{excer}

    \begin{proof}
        Veamos que el algoritmo de $f$ sería:
        \begin{lstlisting}
int f(int x, int y, int z){
    if(x == 0) return y;
    else return z;
}
        \end{lstlisting}
        por lo que, $f$ es total computable.
    \end{proof}

    \begin{excer}
        Considere una retícula de calles que conste de $n$ calles que van de este a oeste, atravesadas por $m$ calles que van de norte a sur, de tal suerte que se genere un mapa rectangular con $mn$ intersecciones. Si un peatón se propone caminar (utilizando dichas calles) para llegar desde la esquina noreste hasta la suroeste, caminando únicamente hacia el este o hacia el sur, y cambiando de dirección únicamente en las esquinas, denote por $r(n,m)$ a la cantidad de posibles rutas que nuestro peatón puede tomar. Demuestre que la función $\cf{r}{\mathbb{N}^2}{\mathbb{N}}$ es total computable.
    \end{excer}

    \begin{proof}
        El conjunto de todas las posibles rutas es:
        \begin{equation*}
            R(n,m)=\left\{(x_1,...,x_{n+m})\Big|x_i\in\left\{s,o\right\}\textup{ y }\sum_{ i=1}^Nx_i = ms+no  \right\}
        \end{equation*}
        donde $s$ y $o$ son letras arbitrarias en un grupo libre abeliano sobre $\left\{s,o\right\}$ dado (esto nomás es para formalizar que se puede hacer esta suma, xd). Básicamente lo que estamos haciendo es codificar todas las posibles rutas que puede tomar el peatón. Un elemento de $R(n,m)$ es una codificación de una ruta que da $m$ giros al sur y $n$ giros al oeste. Su cardinalidad es:
        \begin{equation*}
            r(n,m)=\abs{R(n,m)}=\binom{n}{m}
        \end{equation*}
        (soy malísimo en combinatoria, una explicación está buscando esto en google): \href{https://polypad.amplify.com/es/lesson/paths-on-a-grid}{Paths on a grid}. Por lo que, $r$ es total computable ya que $\binom{n}{m}$ es total computable por ser el factorial y la división funciones computables.
    \end{proof}

    \begin{excer}
        Proporcione un ejemplo de una función no-total, $\cf{g}{\mathbb{N}^2}{\mathbb{N}}$, tal que la función $\cf{h}{\mathbb{N}}{\mathbb{N}}$ obtenida por medio de una búsqueda no acotada:
        \begin{equation*}
            h(x)=(\mu y)(g(x,y)=0)
        \end{equation*}
        sí es total.
    \end{excer}

    \begin{sol}
        Considere la función no total $\cf{g}{;\mathbb{N}}{\mathbb{N}}$ dada por:
        \begin{lstlisting}
int g(int x, int y){
    if(y == 0) return 0;
    else{
        for(int i; 1; i++){}
    }
}
        \end{lstlisting}
        la función $g$ sería:
        \begin{equation*}
            g(x,y)=\left\{
                \begin{array}{lcr}
                    0 & \textup{ si } & y=0\\
                    \uparrow & \textup{ e.o.c. } & \\
                \end{array}
            \right.,\quad\forall (x,y)\in\mathbb{N}^2
        \end{equation*}
        Esta función no es total computable, pero la función $h$:
        \begin{equation*}
            h(x)=(\mu y)(g(x,y)=0)
        \end{equation*}
        siempre está definida para todo $x$, pues el mínimo valor de $g$ ocurre cuando $y=0$ sin importar la entrada de $x$, así que $\mu$ siempre en la búsqueda no acotada encuentra el valor mínimo, así que,
        \begin{equation*}
            h(x)=0,\quad\forall x\in\mathbb{N}
        \end{equation*}
        la cual es total computable.
    \end{sol}

    \begin{mydef}
        El operador $\mu$ significa \textbf{el mínimo tal que}, en caso de que exista (y la función queda sin definir en caso de que no). El acto de invocar a $\mu$ se conoce como búsqueda no acotada.
    \end{mydef}

    \begin{excer}
        Demuestre que si $X\subseteq\mathbb{N}$ es el conjunto de números de Gödel de máquinas de Turing (es decir, $n\in X$ si y sólo si $\varphi(n,\cdot)$ es una máquina de Turing válida, en donde $\varphi$ es la máquina de Turing universal), entonces la función característica $\chi_X$ es total computable.
    \end{excer}

    \begin{proof}
        Debido a que en el simulador de máquinas de Turing, el mismo puede detectar si una máquina de Turing es válida o no (a partir de sintaxis, estados, movimientos, etc...), llamemos a este algoritmo {\fontfamily{cmtt}\selectfont verificarMaquinaTuring}. Se tiene pues el algoritmo siguiente:

        \begin{lstlisting}
int chi_X(int n){
    convertir el entero n a la maquina de Turing correspondiente y guardarlo en la variable strMaquina;
    return verificarMaquinaTuring(strMaquina);
}
        \end{lstlisting}
        ya que la función {\fontfamily{cmtt}\selectfont verificarMaquinaTuring} siempre evalúa si una máquina de Turing es válida o no, por lo que $X$ es un conjunto total computable.
    \end{proof}

    \begin{excer}
        Haga lo siguiente:
        \begin{enumerate}[label = \textit{(\alph*)}]
            \item Construya una función $h$ que \textbf{eventualmente domine} a todas las funciones computables, es decir, que para toda función computable $f$ exista un $N\in\mathbb{N}$ tal que $f(n)\leq h(n)$ para todo $n\geq N$.
            
            \textit{Sugerencia}. Hay por lo menos tres maneras naturales de definir a $h$.
            \item ¿Es posible lograr en el inciso anterior que la función $h$ sea total computable?
        \end{enumerate}
    \end{excer}

    \begin{sol}
        De \textit{(a)}: Como el conjunto
        \begin{equation*}
            \left\{\cf{f}{\mathbb{N}}{\mathbb{N}}\Big|f\textup{ es computable} \right\}
        \end{equation*}
        es numerable, podemos hacer una enumeración de todas las funciones, digamos $\left\{f_i\Big|i\in\mathbb{N} \right\}$.
        Considere ahora la función $\cf{h}{\mathbb{N}}{\mathbb{N}}$ dada por:
        \begin{equation*}
            h(n)=\max_{0\leq i\leq n}f_i(n)
        \end{equation*}
        
        Claramente la función $h$ es computable, veamos que eventualmente domina a todas las funciones computables. En efecto, si $\cf{f}{\mathbb{N}}{\mathbb{N}}$ es computable, entonces existe $N\in\mathbb{N}$ tal que $f=f_N$. Ahora, para todo $n\geq N$ se cumple que:
        \begin{equation*}
            \begin{split}
                h(n)&=\max_{ 0\leq i\leq n}f_i(n)\\
                &\geq f_N(n)\\
                &=f(n)\\
            \end{split}
        \end{equation*}

        De \textit{(b)}: Si $h$ fuese total computable, entonces en particular, $h+1$ sería total computable, en particular computable, luego existiría $N\in\mathbb{N}$ tal que:
        \begin{equation*}
            h(n)\geq h(n)+1,\quad\forall n\geq N
        \end{equation*}
        lo cual no puede suceder, por lo que en algún momento la función $h$ no debe de poder estar definida (para que no haya contradicciones), así que $h$ no puede ser total computable.
    \end{sol}

    \begin{excer}
        Dado un algoritmo $\mathcal{A}$ y un $t\in\mathbb{N}\cup\left\{0\right\}$, la \textit{foto instantánea de $\mathcal{A}$ en el tiempo $t$} es una compliación de toda la información que se encuentra en el algoritmo en el instante de tiempo $t$.

        Demuestre que, si un algoritmo eventualmente se detiene, entonces todas las fotos instantáneas previas a la foto instantánea terminal (es decir, aquella que corresponde al tiempo en el cual el algoritmo se detiene) deben de ser distintas dos a dos.
    \end{excer}

    \begin{proof}
        Probaremos la contrapositiva. Si hubiera dos fotos iguales sucesivas en el los tiempos $t$ y $t+1$, entonces cuando siguiera corriendo el programa en el tiempo $t+2$, la información pasaría exactamente igual que cuando pasó del tiempo $t$ al tiempo $t+1$, es decir que sería la información del tiempo $t$.
        
        Por inducción se puede probar rápidamente que para todo tiempo $t+n$ con $n\in\mathbb{N}$, la información del algoritmo es la misma que en el tiempo $t$, por lo que el algoritmo nunca se detiene (a menos que se haya detenido en el tiempo $t$).
    \end{proof}

    \begin{exa}
        En el ejercicio anterior, un ejemplo sería si concebimos a nuestro algoritmo como una máquina de Turing, entonces la foto instantánea en el tiempo $t$ es un conjunto que contiene al $t$-ésimo estado visitado, así como el contenido de la cinta (visto como una sucesión finita de símbolos del alfabeto correspondiente junto con el símbolo \textit{en blanco}) justo en el momento en que se visita ese $t$-ésimo estado, así como la posición exacta del cabezal lector/escritor en ese momento.

        Por otra parte, si concebimos a nuestro algoritmo como un programa en algún lenguaje de programación, entonces la foto instantánea en el tiempo $t$ consta de la información acerca de los valores que tienen las variables en el momento de correr la $t$-ésima instrucción, así como el reglón del programa que se está corriendo en ese momento.
    \end{exa}

    \begin{excer}
        Recuerde que un conjunto no vacío $X\subseteq\mathbb{N}$ es \textbf{computablemente enumerable} si y sólo si $X$ es el rango de alguna función total computable. Demuestre ahora que un conjunto no vacío $X\subseteq\mathbb{N}$ es computable si y sólo si $X=\textup{ran}(f)$ para alguna función $\cf{f}{\mathbb{N}}{X}$ total computable que es \textit{no decreciente}.
    \end{excer}

    \begin{proof}
        $\Rightarrow)$: Suponga que $X\subseteq\mathbb{N}$ es computable, entonces su función característica $\chi_X$ es total computable. Considere ahora la función $\cf{f}{\mathbb{N}}{\mathbb{N}}$ dada por:
        \begin{equation*}
            f(n)=\max\left\{\max\left\{m\in\mathbb{N}\Big|(m\leq n \textup{ y }\chi_X(m)=1)\textup{ o }m==n_0 \right\}\right\}
        \end{equation*}
        donde $n_0\in\mathbb{N}$ es el mínimo número no negativo tal que $n_0\in X$, el cual existe por ser $X$ un conjunto no vacío. Esta función es computable pues tiene como algoritmo:
        \begin{lstlisting}
int f(int n){
    if(chi_X(n)) return n;
    else{
        while(chi_X(n) == 0) n--;
        if( n >= 0) return n;
        else return n_0;
    }
}
        \end{lstlisting}
        En esencia, esta función codifica una búsqueda yendo de mayor a menor de valores que sean positivos para $\chi_X$. Al encontrar el más grande lo retorna y en caso de no encontrar ninguno, retorna el valor más pequeño. Por lo cual, va retornando todos los elementos de $X$, enlistandolos de forma no decreciente. La función $f$ es total computable por ser $\chi_X$ total computable y por la forma en que se definió, es claro que 

        $\Leftarrow)$: Suponga que $X=\textup{ran}(f)$ para alguna función total computable $\cf{f}{\mathbb{N}}{\mathbb{N}}$ no decreciente. Se tienen dos casos, la función es acotada o no acotada.

        \begin{itemize}
            \item Si $f$ es acotada, tomemos el mínimo $M_0\in\mathbb{N}$ tal que $f(n)\leq M_0$ para todo $n\in\mathbb{N}$. Se tiene el siguiente algoritmo de $\chi_X$:
            \begin{lstlisting}
int chi_X(int n){
    if(M_0 < n) return 0;
    else{
        for(int i = 0; f(i) < n; i++){}
        if(f(i) == n) return 1;
        else return 0;
    }
}
            \end{lstlisting}
            \item Si $f$ es no acotada, se tiene el siguiente algoritmo de $\chi_X$:
            \begin{lstlisting}
int chi_X(int n){
    for(int i = 0; f(i) < n; i++){}
    if(f(i) == n) return 1;
    else return 0;
}
            \end{lstlisting}
        \end{itemize}
        en ambos casos, la función $\chi_X$ es total computable, por lo que $X$ es computable.

    \end{proof}

    \begin{excer}
        Sea $A\subseteq\mathbb{N}$ un conjunto infinito, computablemente enumerable.
        \begin{enumerate}[label = \textit{(\alph*)}]
            \item Demuestre que existe una función total computable $\cf{g}{\mathbb{N}}{\mathbb{N}}$ que es estrictamente creciente tal que $\textup{ran}(g)\subseteq A$.
            \item Concluya que todo conjunto computablemente enumerable infinito contiene un subconjunto computable infinito.
        \end{enumerate}
    \end{excer}

    \begin{proof}
        De \textit{(a)}: Considere el algoritmo {\fontfamily{cmtt}\selectfont enlistarElementosA} que va enlistando los elementos de $A$ (no necesariamente de forma sucesiva). Considere la función $\cf{g}{\mathbb{N}}{\mathbb{N}}$ con algoritmo:
        \begin{lstlisting}
int g(int n){
    int k;
    sea c el primer numero impreso por enlistarElementosA;
    if(n == 0) return c;
    else{
        vamos guardando en k la ultima impresion de enlistarElementosA a la par que este algoritmo se va corriendo, hacemos esto en bucle{
            if(k > g(n-1)) return k;
        }
    }
}
        \end{lstlisting}
        Analicemos lo que hace el algoritmo. Para $n=0$ retorna $g(0)$ es el primer valor que se retorna de enlistar a $A$. Para $n=1$ retorna el siguiente valor más grande que $g(0)$ que imprime el algoritmo después, sucesivamente va imprimiendo valores crecientes. Esta función es total computable, pues al ser $A$ un conjunto infinito, siempre habrá valores más y más grandes, por lo que nunca se quedará estancado.

        Así que $g$ es total computable y toma todos los valores en $A$, por lo que $\textup{ran}(g)\subseteq A$.

        De \textit{(b)}: Sea $B$ un conjunto infinito computablemente enumerable. Por el inciso \textit{(a)} existe una función total computable creciente $g$ tal que $\textup{ran}(g)\subseteq B$. Por el ejercicio anterior, $\textup{ran}(g)$e es un conjunto computable ya que $g$ es no decreciente y éste es infinito por ser $g$ creciente. Así que $\textup{ran}(g)$ es un subconjunto de $B$ computable infinito.
    \end{proof}

    \begin{excer}
        Decimos que un conjunto $X\subseteq\mathbb{N}^k$ es $\Sigma_1^0$ si existe algún conjunto computable $A\subseteq\mathbb{N}^m$ tal que:
        \begin{equation*}
            X=\left\{(x_1,...,x_k)\Big|\exists a_1,...,a_{ m-k}\textup{ tales que }(x_1,...,x_k,a_1,...,a_{m-k})\in A\right\}
        \end{equation*}
        Por otra parte, decimos que un conjunto $Y\subseteq\mathbb{N}^k$ es $\Pi_1^0$ si existe algún conjunto computable $B\subseteq\mathbb{N}^m$ tal que:
        \begin{equation*}
            Y=\left\{(y_1,...,y_k)\Big|\forall b_1,...,b_{ m-k}\textup{ tales que }(y_1,...,y_k,b_1,...,b_{m-k})\in B\right\}
        \end{equation*}
        Demuestre que todo conjunto que es al mismo tiempo $\Sigma_1^0$ y $\Pi_1^0$ es computable.
    \end{excer}

    \begin{proof}
        Sea $X\subseteq\mathbb{N}^k$ un conjunto que es $\Sigma_1^0$ y $\Pi_1^0$. Sean $A,B\subseteq\mathbb{N}^m$ tales que:
        \begin{equation*}
            \begin{split}
                X&=\left\{(x_1,...,x_k)\Big|\exists a_1,...,a_{ m-k}\textup{ tales que }(x_1,...,x_k,a_1,...,a_{m-k})\in A\right\}\\
                &=\left\{(y_1,...,y_k)\Big|\forall b_1,...,b_{ m-k}\textup{ tales que }(y_1,...,y_k,b_1,...,b_{m-k})\in B\right\}\\
            \end{split}
        \end{equation*}
        Afirmamos que $X$ es computablemente enumerable. En efecto, ya que $X$ es $\Sigma_1^0$ podemos ver a $X$ como:
        \begin{equation*}
            X=\left\{m\Big|\exists n\in\mathbb{N}\textup{ para el cual }(m,n)\in A \right\}
        \end{equation*}
        (haciendo una enumeración efectiva de los respectivos productos cartesianos de $\mathbb{N}$ consigo mismo). Por ser $A$ computable se sigue que $X$ es computablemente enumerable.
        
        Veamos que $\mathbb{N}\setminus X$ es computablemente enumerable. En efecto, por lo hecho anteriormente, basta con ver que este conjunto es $\Sigma_1^0$. Como $X$ es $\Pi_1^0$, podemos ver a $X$ (haciendo la descomposición adecuada) como:
        \begin{equation*}
            X=\left\{m\in\mathbb{N}\Big|\forall n\in\mathbb{N}\textup{ se cumple que }(m,n)\in B \right\}
        \end{equation*}
        entonces, el complemento de $X$ será:
        \begin{equation*}
            \mathbb{N}\setminus X=\left\{m\in\mathbb{N}\Big|\exists n\in\mathbb{N}\textup{ tal que }(m,n)\in \mathbb{N}^2\setminus B \right\}
        \end{equation*}
        donde $\mathbb{N}^2\setminus B$ es computable por ser $B$ computable, luego $\mathbb{N}\setminus X$ es enumerablemente computable.
        
        Se sigue así que al ser $X$ y su complemento enumerablemente computables, que $X$ es computable.
    \end{proof}

    \begin{excer}
        Dado un conjunto $X\subseteq\mathbb{N}^k$, demuestre que las siguientes condiciones son equivalentes:
        \begin{enumerate}[label = \textit{(\alph*)}]
            \item $X$ es computablemente enumerable.
            \item O bien $X=\emptyset$, o bien $X$ es el rango de alguna función parcial computable.
            \item Existe una sucesión computable de conjuntos finitos $Y_s\subseteq\mathbb{N}^k$ (lo cual realmente significa: existe un conjunto computable $Y\subseteq\mathbb{N}^{ k+1}$ tal que, para cada $s\in\mathbb{N}$
            \begin{equation*}
                Y_s=\left\{(x_1,...,x_k)\Big|(x_1,...,x_k,s)\in Y \right\}
            \end{equation*}
            ) que satisfacen:
            \begin{equation*}
                Y_s\subseteq Y_{ s+1},\quad\forall s\in\mathbb{N}
            \end{equation*}
            de tal suerte que $X=\bigcup_{ s\in\mathbb{N}}Y_s$
        \end{enumerate}
    \end{excer}

    \begin{proof}
        Es clara la equivalencia entre 

        \textit{(a) $\Rightarrow$ (b)}: Suponga que $X$ es computablemente enumerable y no vacío. Considere la función $\cf{f}{;\mathbb{N}}{\mathbb{N}}$ con algoritmo:
        \begin{lstlisting}
int f(int n){
    correr X en n pasos;
    retornar ultima impresion de X;
}
        \end{lstlisting}
        donde {\fontfamily{cmtt}\selectfont X} es la función que va imprimiendo los elementos de $X$. Claramente esta función es parcial (puede que al principio no imprima nada, pero eventualmente lo hará ya que el conjunto es no vacío) y es computable y además, $X$ es el rango de esta función.

        \textit{(b) $\Rightarrow$ (c)}: 
    \end{proof}

    \begin{excer}
        Demuestre que todo conjunto infinito computablemente enumerable es el rango de alguna función total computable $\cf{f}{\mathbb{N}}{\mathbb{N}}$ que es inyectiva.
    \end{excer}

    \begin{proof}
        Sea $X\subseteq\mathbb{N}$ un conjunto infinito computablemente enumerable. Considere la función $\cf{f}{\mathbb{N}}{\mathbb{N}}$ con algoritmo:
        \begin{lstlisting}
int f(int n){
    el algoritmo de X corre hasta que haya impreso n+1 valores distintos y guarda el ultimo valor en la variable ultimoValor;
    return ultimoValor;
}
        \end{lstlisting}
        esta función es total computable, ya que al ser $X$ un conjunto infinito siempre van a existir $n$ valores distintos para cualquier $n\in\mathbb{N}$. Además, es claro que $f$ es inyectiva ya que siempre va dando valores distintos.
    \end{proof}
        
    \begin{excer}
        Demuestre que si $X\subseteq\mathbb{N}$ es computable y $Y\subseteq\mathbb{N}$ es computable enumerable, entonces $Y$ es computable si y sólo si $X\setminus Y$ es computable.
    \end{excer}

    \begin{proof}
        $\Rightarrow)$: Suponga que $Y$ es computable, entonces $\mathbb{N}\setminus Y$ es computable, luego $X\setminus Y$ es computable.

        $\Leftarrow)$: Suponga que $X\setminus Y$ es computable, entonces al ser $X$ computable, se sigue que $\mathbb{N}\setminus X$ es computable, con lo cual el conjunto:
        \begin{equation*}
            (\mathbb{N}\setminus X)\cup (X\setminus Y)=\mathbb{N}\setminus (X\cap Y)
        \end{equation*}
        es computable. Así que $X\cap Y$ es computable...
    \end{proof}

    \begin{excer}
        Demuestre la \textit{propiedad de reducción}: para cualesquiera dos conjuntos computablemente enumerables $X$ y $Y$ existen conjuntos computablemente enumerables $A\subseteq X$ y $B\subseteq Y$ tales que $A\cap B=\emptyset$ y $A\cup B=X\cup Y$. 
    \end{excer}

    \begin{proof}
        Si $X\cap Y=\emptyset$, tomando $A=X$ y $B=Y$ se sigue el resultado. Suponga que $X\cap Y\neq\emptyset$.
    \end{proof}

    \begin{excer}
        Demuestre que todo conjunto infinito $X\subseteq\mathbb{N}$ contiene un subconjunto que no es computable.
    \end{excer}
    
    \begin{proof}
        Se tienen dos casos:
        \begin{itemize}
            \item \textbf{$X$ no es computable}, en cuyo caso basta con tomar como subconjunto al mismo $X$.
            \item \textbf{$X$ es computable}. Como $X$ es infinito, afirmamos que existe una biyección entre $\mathbb{N}$ y $X$ de tal suerte que ésta sea una función creciente y es una función total computable. En efecto, considere la función:
            \begin{equation*}
                \sigma(n)=\sum_{ i=0}^n \chi_X(i),\quad\forall nn\in\mathbb{N}
            \end{equation*}
            como $X$ es computable, entonces $\chi_X$ es total computable, así que $\sigma$ está definida para todo $n\in\mathbb{N}$. Sea:
            \begin{equation*}
                f=\sigma\big|_{X}
            \end{equation*}
            esta función nuevamente está bien definida para todo $n\in\mathbb{N}$, es total computable y tiene como algoritmo:
            \begin{lstlisting}
int f(int n){
    int cont = 0;
    for(int i = 0; i <= n; i++) cont += chi_X(n)//Esta funcion va contando el numero de numeros de X que aparecen antes de el mismo
    return cont;
}
            \end{lstlisting}
            es claro que $\cf{f}{X}{\mathbb{N}}$ es biyección (ejercicio) y es total computable, pues para cada entrada siempre habrá una salida. Considere el conjunto:
            \begin{eqnarray}
                N=\left\{e\in\mathbb{N}\Big|\varphi(e,e)\textup{ está bien definido} \right\}
            \end{eqnarray}
            este conjunto no es computable. Afirmamos que $f^{-1}(N)\subseteq X$ tampoco lo es. En efecto, si $f^{-1}(N)$ fuese computable, entonces el conjunto imagen bajo $f$ sería computable (por ser $f$ total computable), luego $N$ sería computable. Así que $f^{-1}(N)$ es un subconjunto de $X$ que no es computable.
        \end{itemize}
    \end{proof}

    \begin{excer}
        Dados dos conjuntos $X,Y\subseteq\mathbb{N}$, definimos la \textbf{yunta} de $X$ y $Y$ como:
        \begin{equation*}
            X\oplus Y=\left\{2n\Big|n\in X \right\}\cup\left\{2n+1\Big|n\in Y \right\}
        \end{equation*}
        \begin{enumerate}[label = \textit{(\alph*)}]
            \item Demuestre que, si $X$ y $Y$ son ambos computables, entonces $X\oplus Y$ también lo es.
            \item Demuestre que, si $X$ y $Y$ son ambos computablemente enumerables, entonces $X\oplus Y$ también lo es.
            \item Demuestre que, si $X\oplus Y$ es computable, entonces tanto $X$ como $Y$ también son computables.
            \item Demuestre que, si $X\oplus Y$ es computablemente enumerable, entonces tanto $X$ como $Y$ también son computablemente enumerables.
        \end{enumerate}
    \end{excer}

    \begin{proof}
        
    \end{proof}

    \begin{obs}
        En términos de grados de Turing, la yunta es importante porque representa al supremo de los grados de Turing de los conjuntos correspondientes.
    \end{obs}

    \begin{excer}
        Considere una codificación de los algoritmos de enumeración por medio de números naturales, y denote al conjunto impreso por el $n$-ésimo algoritmo como $W_n$ (en otras palabras, $W_n$ representa al $n$-ésimo conjunto computablemente enumerable, de acuerdo con alguna enumeración efectiva).
        \begin{enumerate}[label = \textit{(\alph*)}]
            \item Demuestre que, si $\cf{f}{\mathbb{N}}{\mathbb{N}}$ es una función total computable, entonces
            \begin{equation*}
                \bigcup_{ n=1}^\infty W_{f(n)}
            \end{equation*}
            es computablemente enumerable (en otras palabras, las uniones computables de conjuntos computablement enumerables son computablemente enumerables).
            \item ¿Es posible afirmar algo acerca de la computabilidad/computable enumerabilidad del conjunto $\bigcap_{ n=1}^\infty W_{f(n)}$?
            \item Demuestre que existe una función parcial computable $\cf{f}{;\mathbb{N}}{\mathbb{N}}$ tal que $f(n)$ está definida siempre que $W_n\neq\emptyset$, en cuyo caso $f(n)\in W_n$ (en otras palabras, se cumple el \textbf{axioma de elección computable}).
            \item Dada una relación binaria $R\subseteq\mathbb{N}^2$ computablemente enumerable, exhiba una función parcial computable $\cf{f}{;\mathbb{N}}{\mathbb{N}}$ tal que $f(n)$ esté definida siempre que $(n,m)\in R$ para algun $m\in\mathbb{N}$, en cuyo caso, además debe cumplirse que $(n,f(n))\in R$.
        \end{enumerate}
    \end{excer}

    \begin{proof}
        
    \end{proof}

    \begin{excer}
        Definamos los siguientes subconjuntos de $\mathbb{N}$:
        \begin{equation*}
            \begin{split}
                X&=\left\{n\in\mathbb{N}\Big|\varphi(n,n)=0 \right\},\\
                Y&=\left\{n\in\mathbb{N}\Big|\varphi(n,n)=1 \right\},\\
            \end{split}
        \end{equation*}
        (donde $\varphi$ reprsenta la máquiana de Turing universal).
        \begin{enumerate}[label = \textit{(\alph*)}]
            \item Demuestre que $X$ y $Y$ son conjuntos computablemente enumerables, amén de que $X\cap Y=\emptyset$.
            \item Demuestre que $X$ y $Y$ son \textbf{computablemente inseprables}: en otras palabras, no existe ningún conjunto computable $Z$ tal que $X\subseteq Z$ y $Y\cap Z=\emptyset$. 
            
            \textit{Sugerencia.} Diagonalización, es decir, si existiera tal $Z$, su función característica sería $\varphi(d,\cdot)$ para algún $d\in\mathbb{N}$; luego, ¿qué podemos decir de $\varphi(d,d)$?
        \end{enumerate}
    \end{excer}

    \begin{proof}
        
    \end{proof}

\end{document}
